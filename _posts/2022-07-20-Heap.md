---
title:  "[Data Structure/Python] Heap"
excerpt: "Heap에 대해 알아보자"

use_math: true                    # latex 적용

toc: true                         # 목차
toc_sticky: true                  # 목차 사이드바 고정
  
published: true                   # 배포 여부

categories:
  - Python
tags:
  - Data Structure
  - Heap
  - Binary Tree
last_modified_at: 2022-07-20T10:30:00+09:00
sitemap:
  changefreq: daily
  priority: 0.8
---
학습을 위하여 [링크](https://www.fun-coding.org/Chapter11-heap.html "잔재미코딩") 사이트를 참조 하였습니다.
# Heap
+ 최대값(Max)과 최소값(Min)의 빠른 검색을 위한 완전 이진 트리(Complete Binary Tree)
+ 일반 리스트나 배열에서 최대/최소값 검색의 시간복잡도는 $O(n)$이지만, 힙에서는 $O(\log N)$으로 빠름
+ 특징
    + 부모 노드의 값 >= 자식 노드의 값
    + 데이터 삽입 시, 좌측 최하단 노드 부터 삽입(완전 이진 트리의 특징)

## 힙과 이진 탐색 트리와의 관계
+ 힙과 이진 탐색 트리(Binary Search Tree) 모두 이진 트리
+ 이진 탐색 트리는 부모 노드를 기준으로 좌측 자식 노드는 작고 우측 자식 노드는 큰값을 가지지만, 힙은 좌우의 크기 상관 없이 부모 노드만 최대/최소값이면 됨 
+ 힙은 최대/최소값 검색을 위해 특화된 구조

## 힙의 동작 방식
+ 데이터 삽입: 좌측 최하단 노드 부터 채워짐
+ 데이터 추가: 최하단 형제 노드들 중 좌측 부터 채워지고 채워진 위치에서 부모 노드와 크기 비교 후 자리 바꿈(swap)
<center><img src="https://www.fun-coding.org/00_Images/heap_insert.png" width="50%"></center>  

+ 데이터 삭제(추출): 힙은 일반적으로 최대/최소값을 바로 꺼내 쓰기위해 사용됨으로 최상단 노드를 삭제하고 그 위치에 좌측 최하단부 노드를 삽입, 부모 노드가 큰 값을 가지도록 swap 반복
<center><img src="https://www.fun-coding.org/00_Images/heap_remove.png" width="50%"></center>

## 인덱싱
+ 인덱싱 편의를 위해 최상단 부모 노드(root node) 인덱싱을 1로 지정
+ 부모 노드 인덱싱 = (자식 노드 인덱싱 // 2)
+ 왼쪽 자식 노드 인덱싱 = (부모 노드 인덱싱 * 2) 
+ 오른쪽 자식 노드 인덱싱 = (부모 노드 인덱싱 * 2) + 1

## 유의점
+ 힙은 배열로 저장하더라도 사실은 트리로 표현한 것이기 때문에, 트리의 높이를 $h$라 하고 $N$개의 노드에 대해서 데이터를 추가 또는 삭제할 때, 최악의 경우 root부터 leaf까지 탐색을 해야하기 때문에 $h = \log_2 N$에 가까우므로, 시간 복잡도는 $O(log N)$
    + 즉, 실행 할때 마다 50%의 명령을 제거하여 실행시간을 50% 단축할 수 있음

## 구현 예시
- 클래스 구현

```python
class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)    # 인덱싱 편의(root: 1번)를 위해 삽입
        self.heap_array.append(data)

    def move_up(self, inserted_idx):    # swap 과정
        if inserted_idx <= 1: # 인덱스 값이 1이면 해당 노드가 root, 메서드 종료
            return False
        
        parent_idx = inserted_idx // 2
        if self.heap_array[inserted_idx] > self.heap_array[parent_idx]: # 해당 노드가 부모 노드 보다 클 경우
            return True
        else:
            return False
        
    def insert(self, data):     # 데이터 삽입
        if len(self.heap_array) == 0:
            self.heap_array.append(None)
            self.heap_array.append(data)
            return True
        
        self.heap_array.append(data)
        
        inserted_idx = len(self.heap_array) - 1 # 마지막 데이터 인덱싱 가져오기
        
        while self.move_up(inserted_idx): # 추가된 데이터 인덱싱
            parent_idx = inserted_idx // 2 # 부모 노드 인덱싱
            self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx] # swap
            inserted_idx = parent_idx # 해당 노드 인덱싱 갱신
        
        return True
        
    def pop(self):      # 데이터 추출
        if len(self.heap_array) <= 1:
            return None
        
        # root값 return
        returned_data = self.heap_array[1]
        
        # 최하단 노드를 root로 이동
        self.heap_array[1] = self.heap_array[-1] # 최하단 노드를 root로 옮기기 (-> 동시에 pop 된 데이터 삭제)
        del self.heap_array[-1] # 최하단 노드를 root로 옮겼으므로, 기존 위치의 노드는 삭제
        popped_idx = 1
    
        # 새로운 root의 크기 비교 -> 새로운 root의 값이 자식 노드의 값보다 커질때까지 또는 자식이 없을때까지 실행
        # 자식 노드가 더 크면 swap하고 인덱싱 갱신
        while True:
            left_child_popped_idx = popped_idx * 2
            right_child_popped_idx = popped_idx * 2 + 1
            
            # 왼쪽 자식 노드 없는 경우(이 경우 오른쪽 자식도 없음)
            if left_child_popped_idx >= len(self.heap_array):
                    return returned_data
            # 왼쪽 자식 노드만 있는 경우
            elif right_child_popped_idx >= len(self.heap_array): 
                if self.heap_array[popped_idx] < self.heap_array[left_child_popped_idx]: # 왼쪽 자식 노드 > 부모 노드
                    self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]
                    popped_idx = left_child_popped_idx
                    continue
                else: # 부모의 값이 더 크므로 done
                    return returned_data
            # 양쪽 자식 노드 모두 있는 경우
            else:
                if self.heap_array[left_child_popped_idx] > self.heap_array[right_child_popped_idx]: # 양쪽의 값 비교
                    if self.heap_array[popped_idx] < self.heap_array[left_child_popped_idx]: # 자식 노드 > 부모 노드
                        self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]
                        popped_idx = left_child_popped_idx
                        continue
                    else: # 부모의 값이 더 크므로 done
                        return returned_data
                else:
                    if self.heap_array[popped_idx] < self.heap_array[right_child_popped_idx]: # 자식 노드 > 부모 노드
                        self.heap_array[popped_idx], self.heap_array[right_child_popped_idx] = self.heap_array[right_child_popped_idx], self.heap_array[popped_idx]
                        popped_idx = right_child_popped_idx
                        continue
                    else: # 부모의 값이 더 크므로 done
                        return returned_data
        
        return returned_data
```
- 데이터 입력 및 출력

```python
heap = Heap(15)
heap.insert(10)
heap.insert(8)
heap.insert(5)
heap.insert(4)
heap.insert(20)
heap.heap_array
```

        [None, 20, 10, 15, 5, 4, 8]
    
```python
heap.pop()
```

        20

```python
heap.heap_array
```

       [None, 15, 10, 8, 5, 4]